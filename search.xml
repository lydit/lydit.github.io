<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(原创)批量选择文件]]></title>
    <url>%2F2018%2F02%2F02%2F(%E5%8E%9F%E5%88%9B)%E6%89%B9%E9%87%8F%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243BOOL bInsertFlag = TRUE; CString szPubFile = &quot;&quot;; CFileDialog dlgFileOpen(TRUE, NULL,NULL, OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_ALLOWMULTISELECT | OFN_ENABLESIZING, &quot;jpg(*.jpg)|*.jpg|jpeg(*.jpeg)|*.jpeg|png(*.png)|*.png|avi(*.avi)|*.avi|mp4(*.mp4)|*.mp4|txt(*.txt)|*.txt|&quot;,NULL); //最多可以打开500个文件 dlgFileOpen.m_ofn.nMaxFile = 500 * MAX_PATH; char* ch = new TCHAR[dlgFileOpen.m_ofn.nMaxFile]; dlgFileOpen.m_ofn.lpstrFile = ch; //对内存块清零 ZeroMemory(dlgFileOpen.m_ofn.lpstrFile,sizeof(TCHAR) * dlgFileOpen.m_ofn.nMaxFile); //显示文件对话框，获得文件名集合 if(dlgFileOpen.DoModal() == IDOK)&#123; //获取第一个文件的位置 POSITION pos_file; pos_file = dlgFileOpen.GetStartPosition(); while(pos_file != NULL)&#123; bInsertFlag = TRUE; szPubFile = dlgFileOpen.GetNextPathName(pos_file); for (int i = 0; i &lt; m_list1.GetItemCount(); i++) &#123; if (GetFileName(szPubFile) == GetFileName(m_list1.GetItemText(i,1))) &#123; bInsertFlag = FALSE;// CString szNotify;// szNotify.Format(&quot;%s(%s:%d)&quot;,Get_Resource_String(IDS_STR39),Get_Resource_String(IDS_STR35),i+1);// MessageBox(szNotify,Get_Resource_String(IDS_STR20),MB_OK|MB_ICONINFORMATION);// return; &#125; &#125; if(bInsertFlag) FileInsert(szPubFile,PUBFILESTATE_WAITFORUPLOAD); &#125; &#125; delete[] ch;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)在指定区域显示图片]]></title>
    <url>%2F2018%2F02%2F02%2F(%E5%8E%9F%E5%88%9B)%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173int ShowPIC(CDC *pDC, CString strPath, CRect rect, int ShowType)&#123; CString lastchar; lastchar = &quot;&quot;; lastchar = strPath.Right(3); if(lastchar == &quot;ico&quot; || lastchar == &quot;ICO&quot;) &#123; HICON myicon; myicon = (HICON)LoadImage(NULL, strPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_VGACOLOR); DrawIconEx(pDC-&gt;GetSafeHdc(),rect.left,rect.top,myicon,rect.Width(),rect.Height(),0,NULL,DI_NORMAL); DestroyIcon(myicon); m_PolyAddPara.imageHeight = 32; m_PolyAddPara.imageWidth = 32; &#125; else if(lastchar == &quot;exe&quot; || lastchar == &quot;EXE&quot;) &#123; HICON myicon; myicon = ::ExtractIcon(AfxGetInstanceHandle(),strPath,0); DrawIconEx(pDC-&gt;GetSafeHdc(),rect.left,rect.top,myicon,rect.Width(),rect.Height(),0,NULL,DI_NORMAL); DestroyIcon(myicon); m_PolyAddPara.imageHeight = 32; m_PolyAddPara.imageWidth = 32; &#125; else//显示BMP JPG GIF等格式的图片 &#123; IStream *pStm = NULL;//2017.08.18 CFileStatus fstatus; CFile file; LONG cb; HGLOBAL hGlobal = NULL;//2017.08.18 //打开文件并检测文件的有效性 //if (!file.Open(strPath,CFile::modeRead)) // return -4; // if(!file.GetStatus(strPath,fstatus)) // return -5; //if((cb = fstatus.m_size) == -1) // return -6; if (file.Open(strPath,CFile::modeRead)&amp;&amp; file.GetStatus(strPath,fstatus)&amp;&amp; ((cb = fstatus.m_size) != -1)) &#123; hGlobal = GlobalAlloc(GMEM_MOVEABLE, cb); LPVOID pvData = NULL; if (hGlobal != NULL) &#123; pvData = GlobalLock(hGlobal); if (pvData != NULL) &#123; file.ReadHuge(pvData, cb); GlobalUnlock(hGlobal); CreateStreamOnHGlobal(hGlobal, TRUE, &amp;pStm); &#125; &#125; &#125; else &#123; if(file) file.Close(); return -1; &#125; //打开文件结束 //显示JPEG和GIF格式的图片，GIF只能显示一帧，还不能显示动画， //要显示动画GIF请使用ACTIVE控件。 if(hGlobal == NULL || pStm == NULL) &#123; if(hGlobal != NULL) &#123; //释放内存 GlobalUnlock(hGlobal); GlobalFree(hGlobal); &#125; if(pStm != NULL) &#123; pStm-&gt;Release(); &#125; file.Close(); return -10; &#125; IPicture *pPic = NULL;//F20170818 if(SUCCEEDED(OleLoadPicture(pStm, fstatus.m_size, TRUE, IID_IPicture, (LPVOID*)&amp;pPic))) &#123; OLE_XSIZE_HIMETRIC hmWidth; OLE_YSIZE_HIMETRIC hmHeight; pPic-&gt;get_Width(&amp;hmWidth); pPic-&gt;get_Height(&amp;hmHeight); double fX,fY; //得到图片的高度与宽度 fX = (double)pDC-&gt;GetDeviceCaps(HORZRES)*(double)hmWidth/ ((double)pDC-&gt;GetDeviceCaps(HORZSIZE)*100.0); fY = (double)pDC-&gt;GetDeviceCaps(VERTRES)*(double)hmHeight/ ((double)pDC-&gt;GetDeviceCaps(VERTSIZE)*100.0); m_PolyAddPara.imageHeight = (long)fY; m_PolyAddPara.imageWidth = (long)fX; long nwidth,nheight,nleft,ntop; int Rx,Ry; Rx = rect.Width(); Ry = rect.Height(); nheight = Ry; nwidth = Rx; nleft = rect.left; ntop = rect.top; //检测显示模式 //是否拉伸充满区域显示 if(ShowType == 1) &#123; nheight = Ry; nwidth = Rx; nleft = rect.left; ntop = rect.top; &#125; //是否居中且按正常比例显示 else if(ShowType == 2) &#123; if(fX &lt; Rx) nwidth = (long)fX; if(fY &lt; Ry) nheight = (long)fY; if((fY &gt; Ry) || (fX &gt; Rx)) &#123; double temp,temp2; temp = Ry / fY; temp2 = Rx / fX; if(temp &lt; temp2) &#123; nwidth = (long)(fX * temp); nleft = (Rx-nwidth)/2 + rect.left; &#125; else if(temp &gt;= temp2) &#123; nheight = (long)(fY * temp2); ntop = (Ry - nheight)/2 + rect.top; &#125; &#125; &#125; //用 Render函数显示图片 if(FAILED(pPic-&gt;Render(*pDC,nleft,ntop,nwidth,nheight,0, hmHeight,hmWidth,-hmHeight,NULL))) &#123; //释放内存 GlobalUnlock(hGlobal); GlobalFree(hGlobal); pPic-&gt;Release(); pStm-&gt;Release(); file.Close(); return -2; &#125; pPic-&gt;Release(); //2008.01.31 pStm-&gt;Release(); file.Close(); &#125; else &#123; //释放内存 GlobalUnlock(hGlobal); GlobalFree(hGlobal); pStm-&gt;Release(); file.Close(); return -3; &#125; //释放内存 GlobalUnlock(hGlobal); GlobalFree(hGlobal); &#125; return 1;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)vc6修改系统控件默认风格]]></title>
    <url>%2F2018%2F02%2F02%2F(%E5%8E%9F%E5%88%9B)vc6%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt;&lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;HtAlarmCloudClient.exe.manifest&quot; type=&quot;win32&quot;/&gt;&lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot;/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt;&lt;/trustInfo&gt;&lt;description&gt;Your application description here.&lt;/description&gt;&lt;dependency&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;X86&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot; /&gt; &lt;/dependentAssembly&gt;&lt;/dependency&gt;&lt;/assembly&gt;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)sem_wait实现毫秒级延时]]></title>
    <url>%2F2017%2F12%2F29%2F(%E5%8E%9F%E5%88%9B)sem_wait%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%BB%B6%E6%97%B6%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031static int gettimeofday(struct timeval *tp, void *t)&#123; timeb tv; ftime(&amp;tv); tp-&gt;tv_sec = tv.time; tp-&gt;tv_usec = tv.millitm*1000; return 1;&#125;int sem_timedwait_ms(sem_t *sem, int milliseconds)&#123; struct timespec abstime; struct timeval now; uint64_t tv_nsec; gettimeofday(&amp;now, NULL); tv_nsec = now.tv_usec * 1000 + (milliseconds % 1000) * 1000000; abstime.tv_sec = now.tv_sec + milliseconds / 1000; if(tv_nsec&gt;=1000000000) &#123; tv_nsec -= 1000000000; abstime.tv_sec += 1; &#125; abstime.tv_nsec = tv_nsec; return sem_timedwait(sem, &amp;abstime);&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)hexo next主题中使用文章计数计时功能]]></title>
    <url>%2F2017%2F12%2F21%2F(%E5%8E%9F%E5%88%9B)next%E4%B8%BB%E9%A2%98%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E7%AB%A0%E8%AE%A1%E6%95%B0%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[一定要先安装hexo-wordcount,不然就算配置了next主题,网页中显示的也是空的。安装方法:在hexo目录上右键选择”Git Bash Here”,执行1npm install hexo-wordcount --save 在next目录下,找到_config.yml,找到post_wordcount,修改如下12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 到这边的话，已经初步实现了文章计数计时功能,剩下的就是汉化了,在主题目录下,打开languages\zh-Hans.yml,找打totalcount,修改成总字数或则你任意喜欢的文字,这边是统计博客所有文章字符数的再打开layout_macro\post.swig,找到{ __(‘post.wordcount’) },修改如下123&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt; &#123;&#123; wordcount(post.content) &#125;&#125;字 &lt;/span&gt; 找到{ __(‘post.min2read’) },修改如下123&lt;span title=&quot;&#123;&#123; __(&apos;post.min2read&apos;) &#125;&#125;&quot;&gt; &#123;&#123; min2read(post.content) &#125;&#125;分钟 &lt;/span&gt; 大功告成!!!]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)error LNK2005 ...already defined in MSVCRTD]]></title>
    <url>%2F2017%2F12%2F18%2F(%E8%BD%AC%E8%BD%BD)error%20LNK2005%20...already%20defined%20in%20MSVCRTD%2F</url>
    <content type="text"><![CDATA[编译错误： Error1error LNK2005: _CrtSetCheckCount already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbgheap.obj) Error2error LNK2005: _calloc_dbg already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbgheap.obj) Error3error LNK2005: _free_dbg already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbgheap.obj) Error4error LNK2005: _malloc_dbg already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbgheap.obj) Error5error LNK2005: _amsg_exit already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(crt0dat.obj) Error6error LNK2005: _initterm_e already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(crt0dat.obj) Error7error LNK2005: __CppXcptFilter already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(winxfltr.obj) Error8error LNK2005: __crtCaptureCurrentContext already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(winapisupp.obj) Error9error LNK2005: __crtCapturePreviousContext already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(winapisupp.obj) Error10error LNK2005: __crtTerminateProcess already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(winapisupp.obj) Error11error LNK2005: __crtUnhandledException already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(winapisupp.obj) Error12error LNK2005: _lock already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(mlock.obj) Error13error LNK2005: _unlock already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(mlock.obj) Error14error LNK2005: __crt_debugger_hook already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbghook.obj) Error15error LNK2005: “void __cdecl terminate(void)” (?terminate@@YAXXZ) already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(hooks.obj) Error16error LNK2005: __xi_a already defined in MSVCRTD.lib(cinitexe.obj)\libcmtd.lib(crt0init.obj) Error17error LNK2005: __xi_z already defined in MSVCRTD.lib(cinitexe.obj)\libcmtd.lib(crt0init.obj) Error18error LNK2005: __xc_a already defined in MSVCRTD.lib(cinitexe.obj)\libcmtd.lib(crt0init.obj) Error19error LNK2005: __xc_z already defined in MSVCRTD.lib(cinitexe.obj)\libcmtd.lib(crt0init.obj) Error20error LNK2005: __iob_func already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(_file.obj) Error21error LNK2005: _CrtDbgReportW already defined in MSVCRTD.lib(MSVCR110D.dll)\libcmtd.lib(dbgrptw.obj) 原因：静态库或动态库编译时的设置的Runtime Library和当前工程不一样 解决办法：工程Property -&gt; C/C++ -&gt; Code Generation -&gt; Runtime Library设置为统一的，例如Debug模式下，统一为MTd，Release模式下统一为MT 转自：http://blog.csdn.net/kuikuijia/article/details/48056047]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)socket：10038错误{winSock的一个bug：当closesocket多次错误使用时会导致问题}]]></title>
    <url>%2F2017%2F12%2F15%2F(%E8%BD%AC%E8%BD%BD)socket%2010038%E9%94%99%E8%AF%AF%7BwinSock%E7%9A%84%E4%B8%80%E4%B8%AAbug%20%E5%BD%93closesocket%E5%A4%9A%E6%AC%A1%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E6%97%B6%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%97%AE%E9%A2%98%7D%2F</url>
    <content type="text"><![CDATA[这几天想在一个开源的代码上进行修改，以期研发出一个产品出来。 程序原来是单线程网络程序，需要修改为多线程，修改之后，总是出问题，辅助线程中的recv函数总是运行一阵子之后收到长度为-1的数据报，导致程序运行不正确甚至崩溃。 由于是多线程，只好打日志进行调试，发现一个奇怪的问题。在A线程与B线程中，均使用了socket这个函数来产生socket，竟然会产生两个相同返回值的socket！也就是说，A线程与B线程能同时获得socket值为360的socket，这样当A正在使用360进行数据接收时，B去连接一把，A自然就出错了。 这个问题实在是诡异，因为socket又不是COM组件，是可以直接在线程中共享的，究竟是出了什么问题呢，MSDN和网络上没有见到任何与此问题相关的内容。活脱脱地就是API出错了！按道理这是不可能的事情啊。 实在没辙了，只好review代码，发现程序中有很多这样的语句： if( mSocket != INVALID_SOCKET ) { closesocket( mSocket ); } 这句有什么问题没有？呵呵看起来没什么问题，但是，不容置疑的是，肯定会导致一个socket被关闭多次。本着死马当着活马医的原则，进行修改，每次closesocket之后，将socket的值置为INVALID_SOCKET，运行程序，问题解决。 这个问题也太ft了，windows竟然连这个容错都没有做，按道理这是很好做的，socket实际上只是一个索引值，系统内核在关闭时如果发现已经关闭就不要做操作就可以了。现在看起来，内核里面貌似是一个socket缓冲池，程序在使用的时候使用计数来管理生命周期。这样当一个socket被关闭多次后，再创建改socket之后，系统可能会认为该socket是关闭的（因为计数小于等于0）。所以下次分配的时候，会将该索引重新分配出去。 该问题在vista home版上出现，其他平台又没有问题不得而知，由此可以看出成对编码的好处以及面向对象封装的好处。 转自:http://blog.csdn.net/chen495810242/article/details/42029825 个人注释:在win7上的测试结果,当一个工程调用多个dll的时候，不同的dll之间使用socket这个函数来产生socket，返回值是可能一样的，就会发生连接无缘无故被断开的现象，查了两三天的说]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)解决ssh登录linux速度慢的问题(以centos7为例)]]></title>
    <url>%2F2017%2F12%2F15%2F(%E5%8E%9F%E5%88%9B)%E8%A7%A3%E5%86%B3ssh%E7%99%BB%E5%BD%95linux%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98(%E4%BB%A5centos7%E4%B8%BA%E4%BE%8B)%2F</url>
    <content type="text"><![CDATA[解决步骤: 先备份/etc/ssh/sshd_config,备份命令为 cp /etc/ssh/sshd_config /etc/ssh/sshd_config.bak 1.su (以root用户登录) 2.vi /etc/ssh/sshd_config (编辑配置文件) 3.输入 / ,查找GSSAPIAuthentication 赋值为no 4.输入 /，查找UseDNS,赋值为 no(该项默认不启用的，要把前面的#删除掉) 5.最后输入!wq保存文件并退出 6.重启systemctl restart sshd]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)随机串的产生,可以用于盐值]]></title>
    <url>%2F2017%2F12%2F15%2F(%E5%8E%9F%E5%88%9B)%E9%9A%8F%E6%9C%BA%E4%B8%B2%E7%9A%84%E4%BA%A7%E7%94%9F%2C%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E7%9B%90%E5%80%BC%2F</url>
    <content type="text"><![CDATA[之前要加密密码的时候，要加入盐值以加强强度，找了部分，又在网上的基础上修改了下(参考网页:http://blog.csdn.net/wangchangshuai0010/article/details/17188417)123456789101112131415161718192021222324252627282930313233343536//产生长度为length的随机字符串 char pSymbol[] = &#123;&apos;~&apos;,&apos;`&apos;,&apos;!&apos;,&apos;@&apos;,&apos;#&apos;,&apos;$&apos;,&apos;%&apos;,&apos;^&apos;,&apos;&amp;&apos;, &apos;*&apos;,&apos;(&apos;,&apos;)&apos;,&apos;_&apos;,&apos;+&apos;,&apos;-&apos;,&apos;=&apos;,&apos;&#123;&apos;,&apos;&#125;&apos;,&apos;|&apos;,&apos;[&apos;,&apos;]&apos;, &apos;:&apos;,&apos;;&apos;,&apos;&lt;&apos;,&apos;&gt;&apos;,&apos;?&apos;, &apos;,&apos;,&apos;.&apos;,&apos;\&quot;&apos;,&apos;\\&apos;,&apos;\&apos;&apos;,&apos;/&apos;&#125;;char* getRandomString(int length) &#123; int nRand, i; char* string; srand((unsigned) time(NULL )); if ((string = (char*) malloc(length + 1)) == NULL ) return NULL ; for (i = 0; i &lt; length - 1; i++) &#123; nRand = rand() % (sizeof(pSymbol) + 26 * 2 + 10); if (nRand &gt;= 0) &#123; if (nRand &lt; 26) string[i] = &apos;A&apos; + nRand; else if (nRand &lt; 52) string[i] = &apos;a&apos; + nRand - 26; else if (nRand &lt; 62) string[i] = &apos;1&apos; + nRand - 52; else if(nRand - 62 &lt; sizeof(pSymbol)) string[i] = pSymbol[nRand - 62]; else string[i] = &apos;x&apos;; &#125; else string[i] = &apos;x&apos;; &#125; string[length] = &apos;\0&apos;; return string; &#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>加解密算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)linux下Microsoftcpprestsdk支持https(server)]]></title>
    <url>%2F2017%2F12%2F15%2F(%E5%8E%9F%E5%88%9B)linux%E4%B8%8BMicrosoftcpprestsdk%E6%94%AF%E6%8C%81https(server)%2F</url>
    <content type="text"><![CDATA[原创，转载请标明源地址 之前看网上一堆的资料说Microsoft/cpprestsdk不支持https或者说只支持window下的https，差点就被误导了，没办法，只好自己去翻了下源代码 先说明下linux版本把，centos7 创建ssl证书啥的，网上一堆的资料，这边就不再说了，直接贴源代码了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;stdio.h&gt;#include &lt;cpprest/uri.h&gt;#include &lt;cpprest/http_listener.h&gt;#include &lt;cpprest/http_client.h&gt;#include &lt;cpprest/asyncrt_utils.h&gt;#include &lt;cpprest/filestream.h&gt;#pragma comment(lib, "cpprest_2_7.lib")#pragma comment(lib, "bcrypt.lib")#pragma comment(lib, "crypt32.lib")#pragma comment(lib, "winhttp.lib")#pragma comment(lib, "httpapi.lib")using namespace web;using namespace http;using namespace utility;using namespace http::experimental::listener;using namespace web::http;using namespace web::http::client;//using namespace concurrency; class CommandHandler&#123;public: CommandHandler() &#123;&#125; CommandHandler(utility::string_t url,http_listener_config server_config); pplx::task&lt;void&gt; open() &#123; return m_listener.open(); &#125; pplx::task&lt;void&gt; close() &#123; return m_listener.close(); &#125;private: void handle_get(http_request message); void handle_post(http_request message); void handle_put(http_request message); void handle_del(http_request message); http_listener m_listener;&#125;;CommandHandler::CommandHandler(utility::string_t url,http_listener_config server_config) : m_listener(url,server_config)&#123; m_listener.support(methods::GET, std::bind(&amp;CommandHandler::handle_get, this, std::placeholders::_1)); m_listener.support(methods::POST, std::bind(&amp;CommandHandler::handle_post, this, std::placeholders::_1)); m_listener.support(methods::PUT, std::bind(&amp;CommandHandler::handle_put, this, std::placeholders::_1)); m_listener.support(methods::DEL, std::bind(&amp;CommandHandler::handle_del, this, std::placeholders::_1));&#125; void CommandHandler::handle_get(http_request message)&#123; ucout &lt;&lt; "Method: " &lt;&lt; message.method() &lt;&lt; std::endl; ucout &lt;&lt; "URI: " &lt;&lt; http::uri::decode(message.relative_uri().path()) &lt;&lt; std::endl; ucout &lt;&lt; "Query: " &lt;&lt; http::uri::decode(message.relative_uri().query()) &lt;&lt; std::endl &lt;&lt; std::endl; message.reply(status_codes::OK, "ACCEPTED"); &#125;&#125;void CommandHandler::handle_post(http_request message)&#123; //std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, std::vector&lt;unsigned char&gt;&gt;&gt; multipart_form_data = granada::httpex::parserex::ParseMultipartFormData(message); ucout &lt;&lt; "Method: " &lt;&lt; message.method() &lt;&lt; std::endl; ucout &lt;&lt; "URI: " &lt;&lt; http::uri::decode(message.relative_uri().path()) &lt;&lt; std::endl; ucout &lt;&lt; "Query: " &lt;&lt; http::uri::decode(message.relative_uri().query()) &lt;&lt; std::endl &lt;&lt; std::endl; message.reply(status_codes::OK, "POST");&#125; void CommandHandler::handle_put(http_request message)&#123; ucout &lt;&lt; "Method: " &lt;&lt; message.method() &lt;&lt; std::endl; ucout &lt;&lt; "URI: " &lt;&lt; http::uri::decode(message.relative_uri().path()) &lt;&lt; std::endl; ucout &lt;&lt; "Query: " &lt;&lt; http::uri::decode(message.relative_uri().query()) &lt;&lt; std::endl &lt;&lt; std::endl; message.reply(status_codes::OK, "PUT");&#125;void CommandHandler::handle_del(http_request message)&#123; ucout &lt;&lt; "Method: " &lt;&lt; message.method() &lt;&lt; std::endl; ucout &lt;&lt; "URI: " &lt;&lt; http::uri::decode(message.relative_uri().path()) &lt;&lt; std::endl; ucout &lt;&lt; "Query: " &lt;&lt; http::uri::decode(message.relative_uri().query()) &lt;&lt; std::endl &lt;&lt; std::endl; message.reply(status_codes::OK, "DEL");&#125;int main(int argc, char *argv[])&#123; try &#123; //用C++ REST SDK编写HTTP服务端，需要在所有的网络接口上监听时， //Windows下应使用地址"http://*:8080"， //Linux下应使用地址"http://0.0.0.0:8080"。 const char * self_signed_cert = R"(-----BEGIN CERTIFICATE-----MIIDlzCCAn+gAwIBAgIJAP9ZV+1X94UjMA0GCSqGSIb3DQEBBQUAMGIxCzAJBgNVBAYTAkNOMQswCQYDVQQIDAJTSDELMAkGA1UEBwwCU0gxEjAQBgNVBAoMCU1JQ1JPU09GVDERMA8GA1UECwwISFBDLVBBQ0sxEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0xNTA4MTkwOTA0MjhaFw00MzAxMDMwOTA0MjhaMGIxCzAJBgNVBAYTAkNOMQswCQYDVQQIDAJTSDELMAkGA1UEBwwCU0gxEjAQBgNVBAoMCU1JQ1JPU09GVDERMA8GA1UECwwISFBDLVBBQ0sxEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALLv7AAPa+4wYpa+3tqc9HIHhh8kv/MpV2Dm+oKG27iHzOugMNAPqLzMAaWCzDRyw27I+jPS3pzAAu6rQ0v2H6XNrie1YEEV27j1WOUS9iFyvcf6Y+ywUKXvFlN/VM/ZFz9Z8U3jc7Y6unIyoUs8UdX/RRITspb2m7SUxlmLJ+4cqiLrHwstNB2NHIZN72oc8DaS5eBqBdT9h6NO62RSBTrAlR7Vk9eU/5trYkd5+PoCpispvU+7Fe24uVerGgU6Yoyd7DMj+3BpbG3g/VkOlGhgH0DNtbKu3v/XOmnzdZn6dzoOoGFNpG1NeH2Xv0vnvEZP6WG4h/TFSafBJMONNnMCAwEAAaNQME4wHQYDVR0OBBYEFO1mAjAmLk1J0iT93xfczAE5mxgzMB8GA1UdIwQYMBaAFO1mAjAmLk1J0iT93xfczAE5mxgzMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAFB8AACf5O+sPe3PZ8IPgwZb+BCXdoXc2rngR/gOaYO019TZyNLuHRzW9FtplzW25IbQ9Jncb+jmY2Ill7Zf3TX4OhHEwscJ1G2LBaqZfQlwSbYJmCzvRNSzSbF3RigNQD5QhdphvVBdvVGTZnVeatjTOFKUyfhcXf4DMb6eMfaU6il/VJCSMW0j3hYNQjPm3V/PLxnGfd9T4hpCUd8MK2XG4RqJAzh6x/6v0fc6mRHBS5+qTWYSDGFwITrU1pP2L9qFegpmaNAom7bdENU8uivd+vrLnG2fKvFSssjVfaXpFLKAICfTJY9A3/CWnZ1AcbE5El7AadctopihoUrlAb0=-----END CERTIFICATE----- )"; const char * private_key = R"(-----BEGIN PRIVATE KEY-----MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCy7+wAD2vuMGKWvt7anPRyB4YfJL/zKVdg5vqChtu4h8zroDDQD6i8zAGlgsw0csNuyPoz0t6cwALuq0NL9h+lza4ntWBBFdu49VjlEvYhcr3H+mPssFCl7xZTf1TP2Rc/WfFN43O2OrpyMqFLPFHV/0USE7KW9pu0lMZZiyfuHKoi6x8LLTQdjRyGTe9qHPA2kuXgagXU/YejTutkUgU6wJUe1ZPXlP+ba2JHefj6AqYrKb1PuxXtuLlXqxoFOmKMnewzI/twaWxt4P1ZDpRoYB9AzbWyrt7/1zpp83WZ+nc6DqBhTaRtTXh9l79L57xGT+lhuIf0xUmnwSTDjTZzAgMBAAECggEAenzd8lScL1qTwlk6ODAE7SHVX/BKLWv5Um4KwdsLAVCEqC7p+yMdANAtuFzG6Ig+29Fb5KnOlUKjPzmhQZhjpZ4cPzZbg3IxDHV2uqi2L8NZwlDWoik3q770a4fYSMd0sHsjQYwXo4CkLJQX8WaDJpgtcehl8g0yHPVSqe0mEkoLdxdqaZnxprchscxefWaGaysIxEO+V+ZOBaPNf4i8PmBKoMNczWZbLcdKhRL7aLeWngPQp1xSWYoN8fPoonpL2qTSop3Nsc2INpwGcYPAj3vxdasC3+DZ8JEJI2AmxpVB13BLkd3nDzOwimZIlu9Fv+NMJ1vb9XdC249ZOqo68QKBgQDigkws1W429nqDtEtQDr5ebHTdP4gZlNt6vWx5obGLCMBAzoyubfNCCBTCYsCPj8hXxNfiPArPFFkIgEx9+w0n7BlaYL6SD2xD4q+YzA1/j4Loakxc7N9z8Cyu+/YHifvLhzwqgFnkLfFnVq9NTF8TatHUYcrbcpawJLz0wr/cnQKBgQDKPAYNTzqPLOOBaE4DfnJNn2zctGU8G5Xp0L/ED8O1t9AjjV2xVO8PDPNDZAxMzgnIbWeU9iWRSLbr7NloXElKh/QlITjAbSXeHsUruq1SmDgiaUhEtDaaJ1SqSZZWY2BZqNXMdILOCgvZGnOyyBR2U49zuNaRHyhmkmZMdIIKTwKBgQDezAk/hEQfvfuuNpZpzcbEu+uLgKVPfFMSfOYJEdnAB0CLvl80Z6QBzE8XEOmVjHkkk9NBjYuYOsyEhyY2OM2s+hfKBSUOKCt27q+IHRYd5bx+/afVM41rzc8141ISAlBw1rmAmLVSszojSmmuH7PZNpXkULineCPuaISQQEtWJQKBgQDDlaVsvdEuowUsJEo+ys2VELhiAv1dUnh79u1fmrd2SV085P1WAYRqE+Y4qMvUg/emJVjmEeBnT+HI7fmdGpOvRyjxt92BDI5w8WVTU2lI1fqEHTpNZ9Te5WbWgfCpf9axH74VzCCtT74Bq7l1kFdp0IqOKpcpJu8VtETHcG5LtQKBgQC4Tx7El1Xb4hsI4dvEh43j3KBb3evlz6vaqgz0BArahYAz2UkkOYDSOPs4K6aOxxXjO0BjqQqCx/tCPcU5AvLsTlswO+wDLXM1DoKxzFBZL5o8927niqW+vZpzyGc1uPmC1MG7+MDKdZsR+e+9XzJTD4slrGSJrcpLt/g/Jqqdjg==-----END PRIVATE KEY----- )"; boost::asio::const_buffer cert(self_signed_cert, std::strlen(self_signed_cert)); boost::asio::const_buffer key(private_key, std::strlen(private_key)); http_listener_config server_config; server_config.set_ssl_context_callback( [&amp;](boost::asio::ssl::context&amp; ctx) &#123; ctx.set_options(boost::asio::ssl::context::default_workarounds); ctx.use_certificate_chain(cert); ctx.use_private_key(key, boost::asio::ssl::context::pem); &#125;); int nPort = 8080; char pAddr[32]; memset(pAddr,0,sizeof(pAddr)); sprintf(pAddr,"https://0.0.0.0:%d",nPort); utility::string_t address = pAddr;//U("http://0.0.0.0:8080"); uri_builder uri(address); auto addr = uri.to_uri().to_string(); CommandHandler handler(addr,server_config); handler.open().wait(); ucout &lt;&lt; utility::string_t(U("Listening for requests at: ")) &lt;&lt; addr &lt;&lt; std::endl; ucout &lt;&lt; U("Press ENTER key to quit...") &lt;&lt; std::endl; std::string line; std::getline(std::cin, line); handler.close().wait(); &#125; catch (std::exception&amp; ex) &#123; ucout &lt;&lt; U("Exception: ") &lt;&lt; ex.what() &lt;&lt; std::endl; ucout &lt;&lt; U("Press ENTER key to quit...") &lt;&lt; std::endl; std::string line; std::getline(std::cin, line); &#125; return 0;&#125; 下面是访问结果]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)foef注意事项]]></title>
    <url>%2F2017%2F12%2F15%2F(%E5%8E%9F%E5%88%9B)foef%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[原创内容，转载请标明原文地址 我们先来看下下面的代码123456789101112131415//获取文件大小DWORD Get_File_Size(const char* m_FilePath)&#123; unsigned long size; if (_access(m_FilePath, 0) == -1)//文件不存在 2013.09.24 return 0; FILE* fp = fopen( m_FilePath, &quot;rb&quot; ); if(fp==NULL) return 0; fseek( fp, SEEK_SET, SEEK_END ); size=ftell(fp); fclose(fp); return size;&#125; 12345678910111213141516171819BYTE bReadBuf[1024*100]; DWORD dwFileSize = Get_File_Size(&quot;C:\\pub.txt&quot;); AfxMessageBox(IntToStr(dwFileSize)); FILE *fp = fopen(&quot;C:\\pub.txt&quot;,&quot;rb&quot;); if (fp != NULL) &#123; fread(bReadBuf,dwFileSize,1,fp); if (!feof(fp)) AfxMessageBox(&quot;1&quot;); else AfxMessageBox(&quot;2&quot;); int nRe = fread(bReadBuf,1,1,fp); AfxMessageBox(IntToStr(nRe)); if (!feof(fp)) AfxMessageBox(&quot;1&quot;); else AfxMessageBox(&quot;2&quot;); fclose(fp); &#125; 其中pub.txt的文件属性为 弹出的内容分别为64，1，0，2 获取出来的文件大小是正确的，但是如果按照这个大小去读取的话，是会发现，feof返回的是true，但是继续去读取的话，又读取不出来数据，但是这个时候再次判断feof则返回false了， 原因在于，feof只有只有在读取超过的情况下，才会返回false 具体的原因可以看下：http://baike.baidu.com/link?url=mdL8HEylLCJhN1dD6ZKq2EbBexXGn_GEfTDvEh45LFt7PSU4g3iOmPuQWfuOQ79kRxOCqyNUWqkt88iCPCqd9q]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)SHA-256算法 C语言实现]]></title>
    <url>%2F2017%2F12%2F15%2F(%E8%BD%AC%E8%BD%BD)SHA-256%E7%AE%97%E6%B3%95%20C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.如果出现 _ftelli64未定义 的错误，将_ftelli64替换为ftello64。visual c应该不会有这种错误。2.函数的第三个参数是计算后的字符串形式，不需要再转换，详情看示例代码。3.默认计算结果是大写形式，如需小写，将函数中末尾处所有 %08X 替换为 %08x 即可。1234567891011121314/*用法示例*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;extern char* StrSHA256(const char* str, long long length, char* sha256);int main(void)&#123; char text[] = &quot;blackkitty&quot;; char sha256[65]; StrSHA256(text,sizeof(text)-1,sha256); // sizeof()计算的结果包含了末尾的&apos;\0&apos;应减1 puts(sha256); puts(StrSHA256(text,sizeof(text)-1,sha256)); // 函数返回值即sha256，直接输出也可以 return 0;&#125; 使用在线加密验证 http://tool.oschina.net/encrypt?type=2 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SHA256_ROTL(a,b) (((a&gt;&gt;(32-b))&amp;(0x7fffffff&gt;&gt;(31-b)))|(a&lt;&lt;b))#define SHA256_SR(a,b) ((a&gt;&gt;b)&amp;(0x7fffffff&gt;&gt;(b-1)))#define SHA256_Ch(x,y,z) ((x&amp;y)^((~x)&amp;z))#define SHA256_Maj(x,y,z) ((x&amp;y)^(x&amp;z)^(y&amp;z))#define SHA256_E0(x) (SHA256_ROTL(x,30)^SHA256_ROTL(x,19)^SHA256_ROTL(x,10))#define SHA256_E1(x) (SHA256_ROTL(x,26)^SHA256_ROTL(x,21)^SHA256_ROTL(x,7))#define SHA256_O0(x) (SHA256_ROTL(x,25)^SHA256_ROTL(x,14)^SHA256_SR(x,3))#define SHA256_O1(x) (SHA256_ROTL(x,15)^SHA256_ROTL(x,13)^SHA256_SR(x,10))extern char* StrSHA256(const char* str, long long length, char* sha256)&#123; /* 计算字符串SHA-256 参数说明： str 字符串指针 length 字符串长度 sha256 用于保存SHA-256的字符串指针 返回值为参数sha256 */ char *pp, *ppend; long l, i, W[64], T1, T2, A, B, C, D, E, F, G, H, H0, H1, H2, H3, H4, H5, H6, H7; H0 = 0x6a09e667, H1 = 0xbb67ae85, H2 = 0x3c6ef372, H3 = 0xa54ff53a; H4 = 0x510e527f, H5 = 0x9b05688c, H6 = 0x1f83d9ab, H7 = 0x5be0cd19; long K[64] = &#123; 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2, &#125;; l = length + ((length % 64 &gt;= 56) ? (128 - length % 64) : (64 - length % 64)); if (!(pp = (char*)malloc((unsigned long)l))) return 0; for (i = 0; i &lt; length; pp[i + 3 - 2 * (i % 4)] = str[i], i++); for (pp[i + 3 - 2 * (i % 4)] = 128, i++; i &lt; l; pp[i + 3 - 2 * (i % 4)] = 0, i++); *((long*)(pp + l - 4)) = length &lt;&lt; 3; *((long*)(pp + l - 8)) = length &gt;&gt; 29; for (ppend = pp + l; pp &lt; ppend; pp += 64)&#123; for (i = 0; i &lt; 16; W[i] = ((long*)pp)[i], i++); for (i = 16; i &lt; 64; W[i] = (SHA256_O1(W[i - 2]) + W[i - 7] + SHA256_O0(W[i - 15]) + W[i - 16]), i++); A = H0, B = H1, C = H2, D = H3, E = H4, F = H5, G = H6, H = H7; for (i = 0; i &lt; 64; i++)&#123; T1 = H + SHA256_E1(E) + SHA256_Ch(E, F, G) + K[i] + W[i]; T2 = SHA256_E0(A) + SHA256_Maj(A, B, C); H = G, G = F, F = E, E = D + T1, D = C, C = B, B = A, A = T1 + T2; &#125; H0 += A, H1 += B, H2 += C, H3 += D, H4 += E, H5 += F, H6 += G, H7 += H; &#125; free(pp - l); sprintf(sha256, &quot;%08X%08X%08X%08X%08X%08X%08X%08X&quot;, H0, H1, H2, H3, H4, H5, H6, H7); return sha256;&#125;extern char* FileSHA256(const char* file, char* sha256)&#123; /* 计算文件SHA-256 参数说明： file 文件路径字符串指针 sha256 用于保存SHA-256的字符串指针 返回值为参数sha256 */ FILE* fh; char* addlp, T[64]; long addlsize, j, W[64], T1, T2, A, B, C, D, E, F, G, H, H0, H1, H2, H3, H4, H5, H6, H7; long long length, i, cpys; void *pp, *ppend; H0 = 0x6a09e667, H1 = 0xbb67ae85, H2 = 0x3c6ef372, H3 = 0xa54ff53a; H4 = 0x510e527f, H5 = 0x9b05688c, H6 = 0x1f83d9ab, H7 = 0x5be0cd19; long K[64] = &#123; 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2, &#125;; fh = fopen(file, &quot;rb&quot;); fseek(fh, 0, SEEK_END); length = _ftelli64(fh); addlsize = (56 - length % 64 &gt; 0) ? (64) : (128); if (!(addlp = (char*)malloc(addlsize))) return 0; cpys = ((length - (56 - length % 64)) &gt; 0) ? (length - length % 64) : (0); j = (long)(length - cpys); if (!(pp = (char*)malloc(j))) return 0; fseek(fh, -j, SEEK_END); fread(pp, 1, j, fh); for (i = 0; i &lt; j; addlp[i + 3 - 2 * (i % 4)] = ((char*)pp)[i], i++); free(pp); for (addlp[i + 3 - 2 * (i % 4)] = 128, i++; i &lt; addlsize; addlp[i + 3 - 2 * (i % 4)] = 0, i++); *((long*)(addlp + addlsize - 4)) = length &lt;&lt; 3; *((long*)(addlp + addlsize - 8)) = length &gt;&gt; 29; for (rewind(fh); 64 == fread(W, 1, 64, fh);)&#123; for (i = 0; i &lt; 64; T[i + 3 - 2 * (i % 4)] = ((char*)W)[i], i++); for (i = 0; i &lt; 16; W[i] = ((long*)T)[i], i++); for (i = 16; i &lt; 64; W[i] = (SHA256_O1(W[i - 2]) + W[i - 7] + SHA256_O0(W[i - 15]) + W[i - 16]), i++); A = H0, B = H1, C = H2, D = H3, E = H4, F = H5, G = H6, H = H7; for (i = 0; i &lt; 64; i++)&#123; T1 = H + SHA256_E1(E) + SHA256_Ch(E, F, G) + K[i] + W[i]; T2 = SHA256_E0(A) + SHA256_Maj(A, B, C); H = G, G = F, F = E, E = D + T1, D = C, C = B, B = A, A = T1 + T2; &#125; H0 += A, H1 += B, H2 += C, H3 += D, H4 += E, H5 += F, H6 += G, H7 += H; &#125; for (pp = addlp, ppend = addlp + addlsize; pp &lt; ppend; pp = (long*)pp + 16)&#123; for (i = 0; i &lt; 16; W[i] = ((long*)pp)[i], i++); for (i = 16; i &lt; 64; W[i] = (SHA256_O1(W[i - 2]) + W[i - 7] + SHA256_O0(W[i - 15]) + W[i - 16]), i++); A = H0, B = H1, C = H2, D = H3, E = H4, F = H5, G = H6, H = H7; for (i = 0; i &lt; 64; i++)&#123; T1 = H + SHA256_E1(E) + SHA256_Ch(E, F, G) + K[i] + W[i]; T2 = SHA256_E0(A) + SHA256_Maj(A, B, C); H = G, G = F, F = E, E = D + T1, D = C, C = B, B = A, A = T1 + T2; &#125; H0 += A, H1 += B, H2 += C, H3 += D, H4 += E, H5 += F, H6 += G, H7 += H; &#125; free(addlp); fclose(fh); sprintf(sha256, &quot;%08X%08X%08X%08X%08X%08X%08X%08X&quot;, H0, H1, H2, H3, H4, H5, H6, H7); return sha256;&#125; 原文地址:http://blog.csdn.net/c_duoduo/article/details/43889759]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>加解密算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)注意:PreTranslateMessage弹出框出错]]></title>
    <url>%2F2017%2F12%2F14%2F(%E8%BD%AC%E8%BD%BD)%E6%B3%A8%E6%84%8F_PreTranslateMessage%E5%BC%B9%E5%87%BA%E6%A1%86%E5%87%BA%E9%94%99%2F</url>
    <content type="text"><![CDATA[dlg.DoModal()截住了界面消息,所以返回时原来的pMsg的内容已经更改了,消息,窗口句柄都不在是if以前的值了,而且窗口句柄应该是对话框里的子窗口的句柄,所以调用CFrameWnd::PreTranslateMessage(pMsg);时pMsg的窗口句柄是个无效值(窗口已销毁)1234567891011121314151617181920212223242526BOOL CViewUP::PreTranslateMessage(MSG* pMsg)&#123; if (pMsg-&gt;message == WM_KEYDOWN) &#123; if(pMsg-&gt;wParam ==&apos;M&apos; || pMsg-&gt;wParam == &apos;m&apos;)//暂时为按“M”键退出系统 &#123; AfxGetApp()-&gt;m_pMainWnd-&gt;SendMessage(WM_CLOSE,0L,0L); return TRUE; &#125; else if(pMsg-&gt;wParam==&apos;Z&apos; || pMsg-&gt;wParam == &apos;z&apos;)//暂时为按“Z”键启动就地系统 &#123; //激活上一个窗口还是退出??因须要而定 CWnd* pWnd = FindWindow(NULL,_T(&quot;就地站_JD&quot;)); if (pWnd) &#123; pWnd-&gt;ShowWindow(SW_SHOWNA );//SW_SHOWMAXIMIZED); pWnd-&gt;SetForegroundWindow(); return TRUE; &#125; // CAONumValueDlg aoDlg; // aoDlg. DoModal(); &#125; &#125; return CView::PreTranslateMessage(pMsg);&#125; 注意事项 模态窗口极大地简化了一些需要和用户交互的操作，好处显而易见。但这里还是要指出一些需要注意的地方，否则使用的时候很可能会出问题。 影响PreTranslateMessage机制 在使用MFC，WTL等进行开发的时候，经常用到PreTranslateMessage机制，这个机制可以让我们在消息被派发之前先做一些事情。很多人以为PreTranslateMessage是Windows本身支持的，其实不然。PreTranslateMessage是MFC和WTL自己引入的一个概念，完全是和Windows无关的。在MFC和WTL的消息循环中，这两个库的设计者在消息分发之前，人为的加了一些代码，使得整个架构支持这一套机制。 正是如此，如果在正常的流程中弹出了模态窗口，就会使正常的PreTranslateMessage机制失效。因为模态窗口中已经包含了一个消息循环，接管了线程中缺省的消息循环。而这个消息循环是在DialogBox这个API函数中执行的，显然不可能再有PreTranalateMessage机制了。 为了解决这一问题，只有让模态窗口也使用和UI线程相同的消息循环，MFC正是这么做的。在MFC中，对话框类的DoModal函数，并不是调用DialogBox函数，而是直接使用CreateWindows创建一个非模态窗口，在窗口创建成功之后再调用MFC自己的消息循环，这样就可以让PreTranslateMessage继续生效。同时在窗口创建出来之后，必须再做一些别的操作，使这个模态窗口的父窗口失效（一般直接把窗口Disable掉）。同时消息循环里有合适的退出条件，并有恢复现场的一些操作，具体可以查看MFC的DoModal函数。 WTL到目前为止，貌似暂时还没有一个合适的方案来解决这个问题。事实上WTL的PreTranslateMessage机制实现的其实是有点问题的，或许以后会在这方面做一定的增强。 可能导致崩溃 这是一个严重问题，在条件合适的情况下，这个崩溃是必然的。 因为模态窗口弹出来之后，模态窗口后面的代码在窗口关闭之前将不会得到执行。然而此时整个窗口是在正常运行的，对于一些极端的情况，是极有可能造成崩溃的。下面看一个例子：123456789void CTestDlg::OnOK()&#123; CInputDialog dlg; If(dlg.DoModal() == IDOK) &#123; m_nValue = dlg.GetValue(); UpdateData(FALSE); &#125;&#125; 这是一段典型的MFC代码，在绝大多数情况下，不会有任何问题。但是由于模态窗口弹出的时候，只是父窗口不能操作，但别的窗口完全还能正常运行，这时候就非常有可能由于某种原因，CTestDlg类已经销毁了，而CInputDialog却不知道，还在继续执行，结果到了IDOK之后，对CTestDialog类的成员变量m_nValue赋值，就会出现崩溃了。 这个问题，如果在多线程的情况下，将会更加严重。因为在多线程的情况下，将会有更加多的不可预料的因素，所以使用的时候要更加小心。 改成这样就OK了,123456789if (pMsg-&gt; message == WM_CHAR)&#123; MSG msg = *pMsg;//后来发现这样还是有点问题,模态对话框回车后，鼠标不见了 CMyDlg dlg; dlg.DoModal(); *pMsg = msg; //后来发现这样还是有点问题,模态对话框回车后，鼠标不见了 return TRUE;//最终方法还是在这里直接返回吧，破坏消息循环总是不好的。&#125; 我估计是MFC保存了一个当前消息的结构来跟踪消息路由,dlg.DoModal();时这个结构的值都更新好多遍了 /////注意///下面是自己实践的代码123456789101112BOOL CDoctorAdd::PreTranslateMessage(MSG* pMsg)&#123; if(pMsg-&gt;hwnd==((CButton*)GetDlgItem(IDOK))-&gt;m_hWnd &amp;&amp; pMsg-&gt;message==WM_MOUSEMOVE) UpdateData(); if(m_number.IsEmpty()) &#123; CMyDlg dlg; dlg.DoModal(); //return CDialog::PreTranslateMessage(pMsg); return true; &#125;&#125; //呵呵这样就不报错啦 转自:http://blog.sina.com.cn/s/blog_9e2e84050101fnjk.html]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)对于代码审查的认识和理解]]></title>
    <url>%2F2017%2F12%2F14%2F(%E8%BD%AC%E8%BD%BD)%E5%AF%B9%E4%BA%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E7%9A%84%E8%AE%A4%E8%AF%86%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[代码审查应该成为任何重要的软件开发工作中一个基本制度。并不单指产品程序――而是所有东西。而且代码审查也不需要花费很多的时间和人力，但它却能发挥巨大的效果。 从代码审查里能得到什么？ 对于代码审查的认识，在代码提交前，用其他人的眼睛检查一遍，防止bug混入。这是最常见的理解，也是对代码审查的好处的最广泛的认识。 但是，在我看来，这并是它最不重要的。人们确实可以在代码审查中找到一些bug。可是，这些在代码审查中能发现的绝大部分bug，很显然，都是微不足道的bug，程序的作者花几分钟的时间就能发现它们。真正需要花时间去发现的bug不是在代码审查里能找到的。 代码审查的最大的好处在于,如果你是程序员，而且知道将会有其他同事来检查你的代码，你编程态度就完全不一样了。你写出的代码将更加整洁，有更好的注释，更好的程序结构。因为你很在意别人对你的程序的看法。没有代码审查，你可能会认为，你写的程序基本不会有人看到，除非有人用到了，它不会给你带来同等的紧迫感。除此之外，还有一个非常重要的好处。代码审查能传播知识，培养分享的氛围。在很多的开发团队里，经常每一个人负责一个核心模块，每个人都只关注他自己的那个模块。除非是同事的模块影响了自己的程序，他们从不相互交流。这种情况的后果是，每个模块只有一个人熟悉里面的代码。如果这个人休假或辞职了，其他人则束手无策。通过代码审查，至少会有两个人熟悉这些程序。审查者虽然并不能像程序的作者一样对程序和业务十分了解，但他会熟悉程序的设计和架构还有业务的架构，这个极其重要的。 刚开始，大家在代码审查时经常会犯一些错误，导致很多麻烦，特别是一些缺乏经验的审查者，他们在代码审查的时候会给了程序开发者的很不好的感觉，最终导致程序员抵触代码审查制度。 针对所有人的审查 * 首先必须承认：审查者都是根据自己的编程习惯来评判别人的代码。所以很多编程上的主张都是一种个人观点。所以应该讨论它们的利与弊，提出你倾向的观点，迅速的在团队达成一致。 对与审查者和被审查者，大家觉得有压力，感觉非要说点什么，非得找出点什么问题出来才好，别人都提出了点什么，自己多少也得说点吧。（完全不需要。只说一句“这段程序写的真不错。”就可以了） 尽量使用提问或是建议，而不是命令。(“把这个变量命名成:user_id,你觉得怎样？”) 请求说明。(“我不明白。你能解释一下吗？”) 避免代码的归属之争。(“我的”，“不是我的”，“你的”) 不要讽刺,嘲笑别人的代码,避免使用一些会被认为或可能会被认为是有关人身特征的词语。(“笨蛋”，“愚蠢”，“傻逼”，“二”)要把所有人都看作是有魅力的、聪明的、善意的。 要明确。要记着并不是每个人都能理解你的意图。 要谦虚。(“我不能确定——我们来分析一下。”) 不要用“总是”，“从不”，“永远”，“毫无…”这样的修辞语。 如果对于某个代码，有太多的我不理解或大家都有不同的看法，可以组织一个讨论会，或是技术分享，然后把你们的交流形成共识，总结成文档 代码审查，不能时间太短，这样没有太多的效果，但是时间也不能太长。毕竟大家还有其他的工作要做。 让别人审查你的代码 首先要达成共识，理解审查是对事不对人。审查的是你的代码，而不是你。 对审查者的建议表示肯定和感激。(“对，你说的没错。”,“谢谢提醒。我会把它改正。”) 解释为什么代码写成这样，可以说明这段代码的业务逻辑。 整理所作的改动，不必当场改掉，复杂的程序，也可以在以后的迭代中重构它们。 努力站在审查者的立场上理解,同样也要努力理解作者的立场。。 针对你感觉非常好的地方以及不是很好的地方与开发者交流。 找出既能解决问题又能简化代码的方法，让代码变得简单。 提出你的实现方案，但要表现出作者也在考虑这种方案。(“你觉得这里用一个自定义校验如何？”) 程序风格样式和注释，同样也是代码审查的范围，而不仅仅是程序。 原文地址:http://www.cnblogs.com/zhangweizhong/p/4389884.html]]></content>
      <categories>
        <category>编程思想</category>
      </categories>
      <tags>
        <tag>代码审查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(原创)vs2013编程64位程序连接access数据库]]></title>
    <url>%2F2017%2F12%2F14%2F(%E5%8E%9F%E5%88%9B)vs2013%E7%BC%96%E7%A8%8B64%E4%BD%8D%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5access%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[之前一直是vc6上开车，今天因为测试需要，转到了vs2013，之前就写写底层的，还没搞过数据库的，发现网上资料还是很杂乱的，故自己整理了一份出来具体的类已经上传到百度网盘了，所以这边就简单点了，写下调用的代码就好了初始化数据库 1Init_DataBase(); 调用查询显示数据库 123456789101112DBTable hDBTable;DWORD dwCount = DataInertface_GetCount(&amp;hDBTable);int nLogID = 0;for (int i = 0; i &lt; dwCount; i++)&#123; nLogID = 0; if (DataInertface_Read(&amp;hDBTable,&amp;nLogID)) &#123; DebugOut(&quot;[Ht64Bit]nLogID=%d&quot;,nLogID); &#125;&#125;hDBTable.Close(); 补充:之前碰到个问题，就是在编译机器运行正常，但是到目标机器的话，就会出错，最后是安装了AccessDatabaseEngine_X64.exe之后才解决的 百度盘地址链接: https://pan.baidu.com/s/1o7CtHBO 密码: k4n4 原创文章，转载请标原文地址]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>MFC</tag>
        <tag>64位</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
